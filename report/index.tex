\documentclass[a4paper,11pt]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Paquetes utilizados
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Soporte para el lenguaje español
\usepackage{textcomp}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}

% Configuración de página
\usepackage[lmargin=1in, rmargin=1in]{geometry}
\setlength{\parskip}{0.75em}
\setlength{\parindent}{1em}

% Graficos
\usepackage{graphicx}

% Encabezados y pies de pagina
\usepackage{fancyhdr}
\setlength{\headheight}{15.2pt}
\pagestyle{fancy}
\fancyhf{}
\lhead{Kozily}
\rhead{Informe}
\cfoot{\thepage}

% Interpretación de lenguajes
\usepackage{listings}
\lstdefinelanguage{javascript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\bfseries,
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\ttfamily,
  stringstyle=\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
\lstset{
  basicstyle=\small\sffamily,
  columns=fullflexible
}

% Tablas
\usepackage{longtable}
\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

% Urls
\usepackage{url}
\renewcommand{\UrlFont}{\small\tt}

% Referencias
\usepackage[nottoc,numbib]{tocbibind}

% Quoting
\usepackage{csquotes}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Titulo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\thispagestyle{empty}

\begin{titlepage}

  \newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
  \newenvironment{bottompar}{\par\vspace*{\fill}}{\clearpage}

  \center

  \textsc{\LARGE Universidad de Buenos Aires}\\[0.5cm]
  \textsc{\Large Facultad de Ingeniería}\\[1.5cm]

  \includegraphics[scale=0.5]{assets/logo.png}\\[1cm]


  \textsc{\large (75.99) Trabajo Profesional}\\[0.25cm]
  {\huge \bfseries Informe} \\[0.4cm]
  \HRule \\[0.4cm]
  {\huge \bfseries Kozily} \\[0.4cm]
  Un entorno de desarrollo de Oz para estudiantes
  \HRule

  \begin{bottompar}
    \begin{minipage}[t]{.45\linewidth}
      \begin{flushleft}
        {\bfseries Autores:}

        Arana, Andrés          - P. 86.203

        Piano, Sergio          - P. 85.191
      \end{flushleft}
    \end{minipage}
    \hfill
    \begin{minipage}[t]{.45\linewidth}
      \begin{flushright}
        {\bfseries Tutores:}

        Wachenchauzer, Rosa
        
        Ferrigno, Leandro
      \end{flushright}
    \end{minipage}
  \end{bottompar}

\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Documento
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%-----------------------------------------------------------------------
% Abstract
%-----------------------------------------------------------------------
\begin{abstract}

El presente documento describe el proyecto realizado en el contexto de Trabajo Profesional para la carrera de Ingeniería en Informática en la Facultad de Ingeniería de la Universidad de Buenos Aires. El proyecto consistió en la construcción de un entorno de desarrollo y máquina virtual de ejecución para el lenguaje Oz, orientado a apoyar el aprendizaje de los diferentes paradigmas que soporta el mismo, que constituye su principal caso de uso.


\end{abstract}
\clearpage

%-----------------------------------------------------------------------
% Tabla de contenidos
%-----------------------------------------------------------------------
\tableofcontents
\clearpage

%-----------------------------------------------------------------------
% Integrantes
%-----------------------------------------------------------------------
\section{Integrantes}

\subsection{Arana, Andrés}

Estudiante de la carrera de Ingeniería en Informática, con 15 años de experiencia como desarrollador full stack en empresas como Sistemas Bejerman, EDS / HP, Globant y Google.


\subsection{Piano, Matías}

Estudiante de la carrera de Ingeniería en informática. Experiencia de 10 años en sistemas desempeñado en distintas compañías entre ellas, Novamens, TeraCode, BVision, Mercado Libre. Formado como desarrollador de distintos lenguajes enfocado en el lado del backend.


\section{Introducción}

\subsection{Oz}

Oz es un lenguaje multiparadigma diseñado por Gert Smolka en la Université Catholique de Louvain en 1991, especialmente pensado para enseñar conceptos de programación a alumnos universitarios. Fue desarrollado posteriormente en 1996 por Peter Van-Roy y Seif Haridi de
Swedish Institute of Computer Science en conjunto con un manual de estudio canónico: Concepts,Techniques and Models of Computer Programming \cite{ctmcp}.

El libro formaliza el lenguaje y su operación definiendo un modelo explícito de ejecución conocido como máquina abstracta, junto con una semántica operacional detallada de un subconjunto de todas las operaciones del lenguaje conocido como kernel. Por último, se definen transformaciones simples para convertir cualquier instrucción del lenguaje a este subconjunto operacional.

Utilizando estas técnicas, el manual detalla cómo soporta Oz diferentes paradigmas de programación, como son la programación funcional declarativa, la lógica procedural, manejo de estado y objetos. De esta forma se expone al lector a una miríada de técnicas y estilos.

\subsection{Lenguaje kernel}

El lenguaje kernel, en el contexto de Oz, se refiere a un subconjunto pequeño y controlado de instrucciones con una semántica operacional definida. De esta forma se separan los conceptos fundamentales del lenguaje de las abstracciones y conveniencias sintácticas que un lenguaje práctico debe proveer. Es posible definir entonces un modelo de ejecución simple que trabaja con estos conceptos fundamentales, y un conjunto de transformaciones para entender cómo las abstracciones son traducidas a esta plataforma.

Debido a que el kernel es más cercano al modelo de ejecución constituye un lenguaje de bajo nivel. Si bien es posible escribir programas completos utilizando sólo este subconjunto de instrucciones, estos serían más extensos y difíciles de comprender debido a la simplicidad del mismo. El lenguaje completo es más poderoso; una sentencia del lenguaje de alto nivel va a significar un conjunto de sentencias del lenguaje de bajo nivel.

En el siguiente ejemplo construímos un programa simple que realiza una operación matemática sobre dos identificadores. Primero codificamos la solución utilizando el lenguaje completo:

\begin{lstlisting}[language=oz]
local X in
  X = 5 + 10
end
\end{lstlisting}

Este mismo programa en lenguaje kernel se traduce como sigue:

\begin{lstlisting}[language=oz]
local X in
  local E1 in
    local E2 in
      E1 = 5
      E2 = 10
      {Number.'+' X Y Z}
    end
  end
end
\end{lstlisting}


\subsection{Modelos de computación}

Un modelo es una abstracción teórica del mundo real al que podemos utilizar para reducir la complejidad, permitiéndonos ver las características importantes que están detrás de un proceso, ignorando detalles de menor importancia que harían el análisis innecesariamente laborioso.
Con los modelos se pueden hacer predicciones concretas, que se puedan falsear mediante experimentos u observaciones. De esta forma, los modelos dirigen los estudios empíricos en una u otra dirección, al sugerir qué información es más importante conseguir.

En el libro se presenta un amplio resumen de mucho de los modelos de computación más usados. Los modelos son diseñados no solo con una simplicidad formal en mente (sin embargo es importante) pero la base es como un programador puede expresar y razonar con el modelo. Existen muchos modelos prácticos de programación, con diferentes niveles de expresividad, diferentes técnicas de programación y diferentes formas de razonar acerca de ellos. Encontramos que cada uno de los modelos tiene su propio dominio de aplicación.
En el libro podemos encontrar mucho de esos modelos, como se relacionan y como se programa haciendo uso de ellos y como se combinan entre ellos para lograr una amplia ventaja.

Todos los modelos de computación tienen su lugar. No es cierto que modelos con más conceptos son mejores o peores. Esto es porque un nuevo concepto es como otro punto de vista. Agregando un concepto a un modelo de computación introduce nuevas formas de expresión, haciendo algunos programas más simples, pero también lo hace más difícil de pensar. Por ejemplo agregando un estado explícito, con variables mutables, a un modelo de programación funcional, podemos expresar el rango completo de las técnicas de programación orientada a objetos. De todas maneras, pensar en programas orientados a objetos es más difícil que pensar en programas funcionales. La programación funcional consiste en calcular valores con funciones matemáticas. Ninguno de los valores ni de las funciones cambia a través del tiempo. El estado explícito es un camino a modelar cosas que cambian a través del tiempo. Provee un contenedor cuyo contenido puede ser actualizado. El poder real de éste concepto hace que sea más difícil de pensar.

Cada modelo computacional fue originalmente diseñado para ser usado aisladamente. Probablemente más adelante sea una locura utilizar un conjunto de ellos en el mismo programa. Encontramos que esto no sucede en todos los casos. Esto es porque los modelos no son solo bloques monolíticos con nada en común. Por el contrario tienen muchas cosas en común.
Gracias a ello es fácil utilizar varios modelos juntos.
Aunque es técnicamente posible, porque alguien querría utilizar varios modelos en el mismo programa? La respuesta profunda a una pregunta simple. Porque uno no programa con modelos, pero si con conceptos de programación y como elige para combinarlos. Dependiendo de los conceptos que son usados, es posible considerar que uno programa con un modelo en particular. El modelo aparece como un tipo de fenómeno. Cosas precisas se convierten en fáciles y otras cosas aumentan su complejidad y pensar en el programa está solucionando a través de una manera particular. Es prácticamente más natural para un programa bien escrito que utilice diversos modelos. En éste punto la respuesta parecería ser encriptada.

Un principio importante es que los conceptos asociados tradicionalmente con un modelo pueden ser usados con un gran efecto en más modelos generales. Por ejemplo, los conceptos de alcance lexicográfico y high-order programming los cuales están asociados a la programación funcional, son útiles en todos los modelos. Esto es bien conocido por la comunidad de programadores funcionales. Los lenguajes funcionales fueron extendidos con estado explícito.


\subsection{Mozart}

Mozart es un proyecto de comunidad que comenzó con una junta de miembros selectos, entre los que se encuentran los creadores del lenguaje Oz. Previamente, el desarrollo de Mozart era supervisado por dicha junta. El desarrollo ahora es administrado por el grupo de investigación PLDC en UCL.

En el proyecto de Mozart se publicaron papers con las especificaciones del lenguaje, así como una implementación de referencia denominada de la misma forma que la comunidad: Mozart. En adelante, cuando se haga una referencia a Mozart se estará refiriendo a la implementación y no al proyecto.

El sistema Mozart tiene una interfase interactiva que está basada en el editor de texto de Emacs. La interfase es llamada OPI, que hace referencia a Oz Programming Interface. Esta OPI está dividida entre varios memorias, un anotador, un emulador de Oz y un compilador de Oz y mantiene un buffer por cada archivo abierto. Dicha interfase da acceso a distintas herramientas, compilador incremental (que pude compilar casi cualquier fragmento de programa legal), Browser (visualizador de memoria de asignación simple), Panel (uso de recursos), Panel de compilador (configuraciones del compilador y entorno) Panel de distribución (subsistema de distribución incluyendo el tráfico de mensajes) y el Explorador (resolución gráfica interactiva de problemas)

%-----------------------------------------------------------------------
% Descripcion del problema
%-----------------------------------------------------------------------
\section{Descripción del problema}

\subsection{Oz en la enseñanza académica}

Oz se utiliza como lenguaje base con el que se enseña a programar en diferentes universidades del mundo. En la Facultad de Ingeniería de la Universidad de Buenos Aires la materia Teoría de Lenguaje utiliza este enfoque. Los profesores se apoyan principalmente en dos herramientas: el sistema Mozart para ejecutar los diferentes ejemplos, y un conjunto de planillas de cálculo para mostrar detalladamente cómo se ejecuta cada ejercicio siguiendo la semántica operacional del kernel.

En esta sección describimos las limitaciones de estos dos sistemas utilizados.

\subsection{Mozart}

\subsubsection{Instalación}

Para poder tener Mozart, es necesario instalar la aplicación. Existen unos fuentes de instalación del programa que quedaron deprecados desde el 2015, servidos en Sourceforge. Sin embargo, de no encontrarse el instalador para el OS que usamos es necesario hacer build de los sources del proyecto para conseguir a Mozart.

Con motivo de describir en que consiste hacer el build de los sources del proyecto, indicamos que para poder utilizar Mozart, necesitamos acceder al repositorio \url{https://github.com/mozart/mozart2#downloads}, en dónde detalla que el estado de la versión 2. Se menciona que la versión 2 está actualmente en calidad alfa y que no está disponible para producción, pero puede ser usada para experimentar, testear y claramente para contribuir en el desarrollo.

Quienes instalen por primera vez Mozart, se van a encontrar con una dependencia con el editor de texto Emacs. Es necesario tener Emacs para poder usar Mozart. Sin Emacs Mozart no funciona. Ésta aplicación se monta sobre Emacs y permite dar una interfase para poder desarrollar.

\subsubsection{Operación del entorno}

La interfase de comandos para poder operar con Mozart es a través de combinaciones de teclas, lo que hace difícil su uso.

\includegraphics[scale=0.8]{assets/mozart_shortcuts.png}\\[1cm]

Una vez que escribimos el código que queremos ejecutar, no podemos ejecutarlo inmediatamente, es necesario antes poder llenar el buffer con el código nuevo. Podemos llenar el buffer con una de las combinaciones de las teclas o bien yendo al menú de Oz e indicar feed buffer. Una vez lleno el buffer podemos pasar a ejecutar las instrucciones que les indicamos.
Acá va una muestra de como es Mozart.

\includegraphics[scale=0.8]{assets/mozart_example.png}\\[1cm]

\subsubsection{Manejo de errores}

Cuando se presenta un error del lado de Mozart es un arte tratar de entender que significa. Se hace aún más difícil cuando el código que ingresamos es más extenso.

\includegraphics[scale=0.8]{assets/mozart_errors.png}\\[1cm]

\subsection{Visualización del modelo de ejecución}

Los profesores llevan la guía de ejercicios y proponen realizar un ejercicio para que el alumno aprenda como se trabaja con el lenguaje Oz. Con el objetivo de poder mostrar de manera gráfica como funciona la máquina abstracta y como interactúan con los stacks, como se ejecutan los semantic statements y como se maneja los entornos y las memorias, utilizan herramientas como el excel o algún editor de planillas de cálculo.

Si tomamos un ejemplo de los brindado en las clases, que tiene como finalidad indicar como se escribe el código en lenguaje Oz y poder ver como maneja la máquina abstracta, se puede ver más rápido el detalle de los problemas.
Para comenzar vamos a calcular la potencia a la cuarta de 3:

\begin{lstlisting}[language=oz]
local Pow Pow4 in
  Pow = fun {$ N}
	fun {$ X}
	  if N>1 then
        {{Pow N-1} X }*X
	   else
		  X
	       end
	    end
	 end

   Pow4 = {Pow 4}
   {Browse {Pow4 3}}
end
\end{lstlisting}

La construcción del excel de los profesores trata de indicar de manera gráfica como representar lo que está sucediendo. Dejan referencia cuales son los statements que van a ser ejecutados y como se va armando el stack de semantic statements.

\includegraphics[scale=0.8]{assets/ejemplo_clase.png}\\[1cm]

A continuación se puede ver como la máquina abstracta realiza los cálculos. Primero pasa a tomar el statement superior del stack, debido a que el stack es una pila y dicho statement tiene un entorno que le da un contexto para poder ejecutarse. Se ejecuta y en función a lo ejecutado indica como queda el stack.

En el gráfico vamos a indicar un segmento de la representación de lo que implica detallar los pasos de la máquina abstracta. 

\includegraphics[scale=0.8]{assets/ejemplo_clase_3.png}\\[1cm]

Con el ejercicio que les mostramos, el problema al que hacemos referencia es la falta de una herramienta gráfica que represente como es el estado de los stacks dentro de la máquina abstracta de manera sencilla y práctica.

%-----------------------------------------------------------------------
% Propuesta
%-----------------------------------------------------------------------
\section{Propuesta de Solución}

Nuestra idea fue armar una herramienta que permita dar soluciones a los problemas que presentamos en la sección anterior.
A través de los años, fuimos juntando experiencia con diversos lenguajes de programación, aprenderlos dentro o fuera de la facultad, nos fueron formando. De iterados momentos en que interactuamos con entornos de desarrollo distintos, consideramos que los problemas que presenta el entorno de desarrollo podían ser mejorados. Decidimos empezar con la construcción de una interfaz que cumpla con los estándares y que tenga valor agregado atacando los problemas que fuimos mencionamos.

De esta experiencia surgió Kozily, un sistema integrado de desarrollo y máquina virtual de ejecución para el lenguaje Oz y su máquina abstracta.

Se propone que el sistema sea online, accesible con un browser a través de internet, de forma que no sea necesario instalar ni configurar el sistema del alumno para poder empezar a interactuar con la plataforma. De esta forma se permite además que el sistema sea utilizado en celulares, tablets y computadoras tradicionales.

Es de importancia fundamental que la herramienta sea fácil de usar, con una interfase clara y simple. Debe además permitir interactuar con la máquina abstracta subyacente de manera de acceder a los detalles de la ejecución de cada instrucción, el estado de la máquina abstracta y toda la información que los profesores y alumnos necesitan para comprender el modelo de ejecución del lenguaje.

Por último, el sistema utilizará técnicas de mejoramiento progresivo, o PWA por sus siglas en inglés, de manera de soportar muchas de las características de un sistema de escritorio tradición como son el acceso al sistema sin tener conexión a internet

\subsection{Alcance}

El sistema deberá soportar lo siguiente:

\begin{itemize}
    \item Soporte de la sintaxis y semántica del lenguaje Oz como es definido en los capítulos 2, 3, 4, 5 y 6 del manual.
    \item Visualización del lenguaje kernel.
    \item Visualización de la máquina abstracta.
    \item Detección de errores de compilación.
    \item Detección de errores de ejecución.
    \item Control sobre el flujo de datos
    \item Soporte de operaciones built-in básicos
    \item Procedimientos especiales, \texttt{ByNeed}, \texttt{Wait}, \texttt{NewCell}, etc. 
\end{itemize}

Las siguientes características del lenguaje, si bien son parte de los capítulos mencionados en la sección anterior, quedan fuera del alcance del proyecto:

\begin{itemize}
    \item Conjunction and disjunction expressions.
    \item For loops, tanto en su versión imperativa como declarativa.
    \item Manejo de memoria y garbage collector.
    \item Operaciones built-in de caracteres, atoms, records, tuplas, listas y procedures.
    \item Inicialización de variables implícita y declaración implícita de scopes.
    \item Instrucción Browse
\end{itemize}

 
\subsection{Diferencias con la especificación}

La solución no implementará la especificación del lenguaje como es descripta en el manual de manera exacta, desviándose de la misma cuando sea necesario para hacer más clara la ejecución de los programas. De acuerdo a lo elicitado en conversaciones con los profesores, el sistema deberá soportar una adaptación fundamental: la ejecución inline de expresiones simples.

El requisito se debe a que el formalismo de la ejecución de expresiones en el libro genera un código kernel demasiado engorroso y confuso, para algo que es ya relativamente simple de entender como la ejecución de operaciones matemáticas.

%-----------------------------------------------------------------------
% Solucion
%-----------------------------------------------------------------------
\section{Descripción de la solución}

\subsection{Desafíos técnicos}

El sistema presenta ciertos desafíos técnicos interesantes debido a la plataforma de ejecución: compiladores, intérpretes y entornos de desarrollo suelen ser desarrollados para ser ejecutados como binarios nativos. Si bien existen ejemplos de compiladores e entornos de desarrollo online como repl.it\cite{replit} o Codeanywhere\cite{codeanywhere}, estos no son tan comunes y por lo tanto no existe un ecosistema tan desarrollado de librerías y herramientas para construir este tipo de aplicaciones.

Por otro lado, la necesidad de interacción entre el usuario y la máquina abstracta implica patrones de interacción complejos, por lo que una arquitectura web tradicional con un servidor respondiendo a las operaciones del usuario no es un buen paradigma para implementar la solución.

\subsection{Arquitectura}

El sistema es una aplicación web auto contenida progresiva, o PWA por sus siglas en inglés. La totalidad de la aplicación, compuesta por un archivo html, un script javascript, un paquete de estilos y los diferentes assets de presentación es descargada en una primer interacción con un servidor de archivos estático. El browser interpreta el archivo HTML que sólo contiene un esqueleto de la presentación, para luego ejecutar el script javascript de la aplicación. Este script inicializa la interfaz de usuario y configura los callbacks de los diferentes eventos que suceden en la aplicación.

El proceso de compilación es un pipeline en donde cada etapa sólo dependen de la salida de la etapa anterior: 

\begin{enumerate}
    \item El código fuente es primero procesado por el parser generando así una estructura de datos conocida como AST\cite{ast} o abstract syntax tree.
    \item El AST es procesado por el compiler, transformándolo a una nueva estructura de datos que contiene sentencias kernel.
    \item El kernel es procesado por el runtime, construyendo por último el estado inicial de ejecución.
\end{enumerate}

Cada vez que se avanza en la ejecución, se obtiene el primer semantic statement de uno de los stacks del estado y se ejecuta una función específica para cada instrucción que, dado el estado de la máquina abstracta y la instrucción, devuelve el siguiente estado.

Debido a que todos estos proceso sólo dependen del input del resultado del proceso anterior, se modelo el mismo utilizando técnicas de programación funcional, utilizando estructuras de datos persistentes inmutables a través de la librería Immutable.js\cite{immutable}.

\subsection{Parser}

El primer proceso que se ejecuta sobre el código fuente es conocido como parsing\cite{parsing}, y consiste en el análisis del texto ingresado y su transformación en una estructura de datos persistente que representa el AST.

La implementación de este proceso utilizó Nearley\cite{nearley}, una librería que implementa el algoritmo Earley\cite{earley} en javascript. El parser analiza el texto comparándolo con patrones declarativos; en el caso de que la comparación sea exitosa invoca a una función que construye el nodo del AST. El siguiente es un ejemplo de una regla que captura una instrucción de declaración de variables

\begin{lstlisting}
stm_local -> "local" __ stm_local_identifier_list __ "in" __ stm_sequence __ "end" {%
  function(d) {
    return {
      node: "statement",
      type: "localSyntax",
      identifiers: d[2],
      statement: d[6],
    };
  }
%}
\end{lstlisting}

Cabe destacar que este proceso es una función pura desde el punto de vista de la programación funcional.

\subsection{Compilación}

El compilador convierte el AST en un árbol que representa un conjunto de instrucciones kernel. Nuevamente, este proceso es modelado como una función pura: dado que tanto el AST original como el kernel son estructuras de datos persistente\cite{persistentdatastructures}, la nueva estructura de datos derivada no modifica el AST original, y sólo depende de la estructura de datos original. Este algoritmo es recursivo: dada la naturaleza del AST cada nodo debe compilar cualquier subnodo que este contenga.

El modelo de datos del kernel es simple: cada nodo de kernel contiene toda la información del nodo de manera que puede ser procesado de manera independiente. El siguiente ejemplo muestra la estructura de datos para una instrucción de declaración de variables, y el proceso de compilación asociado:

\begin{lstlisting}[language=javascript]
export const localStatement = (identifier, statement) => {
  return Immutable.Map({
    node: "statement",
    type: statementTypes.local,
    identifier,
    statement,
  });
};

export default (recurse, statement) => {
  const childStatement = recurse(statement.get("statement"));
  const identifiers = statement.get("identifiers");

  return identifiers.reduceRight(
    (child, identifier) => localStatement(identifier, child),
    childStatement,
  );
};
\end{lstlisting}

\subsection{Ejecución}

La estructura de datos kernel es posteriormente utilizada en otra estructura de datos que representa un estado inicial de ejecución. Cada estado de ejecución tienen una lista de threads, que inicialmente contiene un único thread con el único statement de kernel resultante del proceso anterior.

Avanzar un paso en la ejecución implica tomar el statement siguiente de uno de los threads y realizar una operación de reducción funcional\cite{fold}: dado el estado actual y el statement actual, devuelve el siguiente estado. Aquí nuevamente es importante remarcar la importancia de las estructuras de datos persistentes; el nuevo estado es una derivación del estado anterior y no una modificación in-situ. Esto permite navegar temporalmente la ejecución sin necesidad de implementar un algoritmo de undo-redo.

El siguiente ejemplo muestra el reductor para la instrucción de creación de variables:

\begin{lstlisting}[language=javascript]
export default function(state, semanticStatement, activeThreadIndex) {
  const identifier = semanticStatement.getIn([
    "statement",
    "identifier",
    "identifier",
  ]);
  const childStatement = semanticStatement.getIn(["statement", "statement"]);

  const newVariable = makeNewVariable({
    in: state.get("sigma"),
    for: identifier,
  });
  const newEquivalenceClass = buildEquivalenceClass(undefined, newVariable);
  const newEnvironment = semanticStatement
    .get("environment")
    .set(identifier, newVariable);
  const newIndex = makeNewEnvironmentIndex();
  const newSemanticStatement = buildSemanticStatement(
    childStatement,
    newEnvironment,
    { environmentIndex: newIndex },
  );

  return state
    .update("sigma", sigma => sigma.add(newEquivalenceClass))
    .updateIn(["threads", activeThreadIndex, "stack"], stack =>
      stack.push(newSemanticStatement),
    );
}
\end{lstlisting}


\subsection{Interfaz de usuario}

Para construir la interfaz que le permite al usuario interactuar con los estados de la máquina abstracta utilizamos React.js\cite{react}. Esta librería permite construir interfaces declarativas utilizando el paradigma de programación funcional: cada componente es una función pura que, dado ciertas propiedades derivadas del estado de la aplicación construye una representación de la vista para ese estado. La librería luego reconcilia esta representación con el estado actual de la interfase.

El siguiente es un ejemplo de un componente de la UI, en particular la barra de navegación:

\begin{lstlisting}[language=javascript]
export const NavBar = props => {
  return (
    <Menu attached borderless fluid size="small" pointing>
      <Menu.Item header icon="home" content="Kozily" />
      <Divider />
      <Menu.Item
        header
        icon="list"
        content="code"
        name="code"
        active={props.activeItem === "code"}
        onClick={() => props.onActiveTabChange("code")}
      />
      <Menu.Item
        header
        icon="setting"
        content="runtime"
        name="runtime"
        active={props.activeItem === "runtime"}
        disabled={!props.hasMachine}
        onClick={() => props.onActiveTabChange("runtime")}
      />
    </Menu>
  );
};
\end{lstlisting}

El estado general de la aplicación, como es el código fuente actual, el paso de ejecución o la sección de la aplicación que se está mostrando en un momento dado se representa utilizando estructuras de datos persistentes y Redux.js\cite{redux}. Nuevamente esta librería representa las transiciones entre los estados, que se dan cuando el usuario genera eventos semánticos en la aplicación, con el patrón de reducción funcional: cada reductor toma el estado actual de la aplicación y un evento semántico y genera un nuevo evento semántico.

El siguiente es un ejemplo de un reductor de redux que maneja la pantalla actual:

\begin{lstlisting}[language=javascript]
export const reducer = (previousState = initialState, action) => {
  switch (action.type) {
    case "CHANGE_TAB": {
      return previousState.set("activeItem", action.payload);
    }
    case "RUNTIME_RUN": {
      return previousState.set("activeItem", "runtime");
    }
    default: {
      return previousState;
    }
  }
};
\end{lstlisting}

El resultado final es una interfaz fluida e interactiva como al que sigue:

\includegraphics[scale=0.5]{assets/kozily_code_example.png}\\[1cm]

En la imagen podemos ver que tenemos en la sección de la izquierda el editor, donde el programador ingresa su código. Al margen derecho se ve el lenguaje Kernel que es el resultado de la compilación del código ingresado.

En la parte superior hay dos tabs que separan la parte del código y de la parte de ejecución.

Si el código del programa que ingresamos compila correctamente aparece en la ventana del kernel. De lo contrario si tiene errores, los errores se muestran en la sección inferior a través de un mensaje en rojo detallando el error de compilación e indicando la linea y columna dónde ocurre.

Si el código fue correctamente compilado, se puede ejecutar.
Para poder ejecutar el código, se da click sobre el botón run, que está en la parte superior de la ventana del code.
Una vez que se ejecuta, se habilita la tab de runtime y lleva al programador a ejecutar sentencia por sentencia.

\includegraphics[scale=0.5]{assets/kozily_runtime_example.png}\\[1cm]

En el sector del runtime tenemos los controles de ejecución del programa en la parte superior y un menú desplegable. Entre los controles de ejecución del programa se encuentran el ir al comienzo de la ejecución e ir al paso anterior dejando el estado de la máquina abstracta como estaba en ese momento. En el menu desplegable podemos habilitar/deshabilitar las variables de sistema ocultas tanto en el entorno como en la memoria sigma.

En la sección intermedia se encuentran los múltiples threads, indicando una columna para los que están listos para ser ejecutados y los que quedan bloqueados por la necesidad de conocer una variable que aún no fue bounded. Aquellos threads que quedaron bloqueados se indican en color rojo y no pueden seguir la ejecución hasta que la variable en cuestión se encuentre bounded.
Los threads que se encuentran en el sector de Ready, se encuentran listos para ser ejecutados.
Un dato adicional y no menor es que el desarrollador puede elegir cual de los threads debe continuar con la ejecución con ánimos de indicar que es lo que hace en cada paso.
Sobre cada una de las sentencias, que están representadas por los cuadrados dentro del componente del thread, si pasamos con el mouse podemos ver la sentencia que se quiere ejecutar en más detalle en un menú desplegable que permite mostrarlo.

En la parte inferior de la pantalla de runtime se encuentran las memorias. La primera memoria es sigma que es la memoria Immutable. La segunda memoria es tau que contiene los triggers. Y por último la memoria mu que es dónde se encuentran los elementos mutables. Cada una de ellas tiene una tabla con las variables que maneja y que valor tiene esa variable. Si pasamos con el mouse sobre una de las variables podemos ver el contenido del valor más completo de como se está mostrando, gracias a un menú desplegable.

\subsection{Plataforma}

El eslabón final de la solución es la puesta en producción. Es necesario compilar el paquete de archivos que se copiará al servidor de archivos estático, preprocesándolo para garantizar un buen desempeño en una variedad de browsers, eliminando código superfluo, comprimiendo los archivos y otra variedad de transformaciones. Se utilizó Webpack\cite{webpack} para realizar todas estas transformaciones, obteniendo como resultado un directorio con todos los archivos que deben copiarse al servidor.

El servidor utilizado es provisto por Surge.sh\cite{surge}, un servicio especializado en hosting de proyectos estáticos que no requieren un servidor dinámico.

%-----------------------------------------------------------------------
% Procesos
%-----------------------------------------------------------------------
\section{Ingeniería de software}

\subsection{Comunicación}

Toda la comunicación necesaria para ejecutar los diferentes procesos se centralizó utilizando Slack\cite{slack}, una aplicación de chat que integraba todos los aspectos de ingeniería de software en el proyecto. Slack permite integrar las diferentes herramientas que utilizamos automáticamente, de manera que constituía el tronco sobre el cuál se estructuraba todo el proceso.

\subsection{Estimación y calendarización}

La estimación y calendarización se realizó con un enfoque minimalista: sólo se realizaron estimaciones de alto nivel en la constitución del proyecto. Para esto se realizó una elicitación inicial utilizando como guía los diferentes capítulos del libro que se necesitaban implementar. Cada capítulo constituyó entonces un milestone que fue registrado en GtiHub\cite{github}, utilizando Milestones\cite{githubmilestones}, y posteriormente estimado. Las estimaciones se registraron como fechas objetivos en los mismos milestones.

El control calendarización se realizó utilizando Toggl\cite{Toggl}, que permitió registrar con exactitud la cantidad de tiempo dedicada a cada tarea.

\subsection{Elicitación de requisitos}

La elicitación de requisitos detallada se realizó basándose en dos fuentes principales. Por un lado, el manual y su especificación formal del lenguaje. Por otro lado, utilizando técnicas de elicitación tradicionales a través de reuniones con los tutores quienes proporcionaron abundante material para analizar en la forma de los materiales con los que se dictan las clases.

\subsection{Metodología de trabajo}

Al comenzar el proyecto se inició con un modelo de procesos basado en  Scrum\cite{scrum}. Sin embargo, la disponibilidad de tiempo de los integrantes hizo difícil llevar adelante esta metodología; es por este motivo que se cambió por un proceso basado en Kanban\cite{Kanban}.

\subsubsection{Scrum}

Scrum es un proceso de gestión y control que reduce la complejidad en el desarrollo de productos para satisfacer las necesidades de los clientes. La gerencia y los equipos de Scrum trabajan juntos alrededor de requisitos y tecnologías para entregar productos funcionando de manera incremental usando el empirismo.

Scrum es un marco de trabajo simple que promueve la colaboración en los equipos para lograr desarrollar productos complejos.

Scrum es simple, no es una gran colección de partes y componentes obligatorios definidos de manera prescriptiva. Scrum no es una metodología, Scrum está basado en un modelo de proceso empírico. con respeto a las personas y basado en la auto-organización de los equipos para lidiar con lo imprevisible y resolver problemas complejos inspeccionando y adaptando continuamente.

Los eventos de Scrum se utilizan para minimizar la necesidad de reuniones no definidas en Scrum y establecer una cadencia que permita al equipo fomentar la comunicación y colaboración reduciendo el tiempo en reuniones extensas además de reducir los procesos restrictivos y predictivos. Todos los eventos tienen una caja de tiempo o “TimeBox”. Una vez que se inicia un Sprint este tiene una duración fija y no se puede acortar o alargar. Los siguientes eventos pueden terminar siempre que se logre el propósito del evento, pero dentro de la caja de tiempo y asegurando el fomento de la transparencia. Los eventos de Scrum son:

\begin{enumerate}
  \item Sprint
  \item Sprint Planning
  \item Daily Scrum
  \item Sprint Review
  \item Sprint Retrospective
\end{enumerate}
Artefactos Scrum

Los artefactos de Scrum formas para proveer transparencia y oportunidades de inspección y adaptación. Los artefactos definidos por Scrum están específicamente definidos para fomentar la transparencia de la información de tal manera que todos tengan el mismo entendimiento de lo que se está llevando a cabo a través de los artefactos. Los artefactos Scrum son:

\begin{enumerate}
  \item Product Backlog
  \item Sprint Backlog
  \item Increment
\end{enumerate}

\subsubsection{Kanban}

Proveniente de Japón, Kanban es un símbolo visual que se utiliza para desencadenar una acción. A menudo se representa en un tablero Kanban para reflejar los procesos de su flujo de trabajo.

Kanban, representada por una tarjeta Kanban, se moverá a través de las diversas etapas de su trabajo hasta su finalización. A menudo se habla de él como un método de extracción, de forma que usted tira de sus tareas a través de su flujo de trabajo, ya que permite a los usuarios mover de sitio libremente las tareas en un entorno de trabajo basado en el equipo.

Los beneficios son:

\begin{enumerate}
  \item Estímulo del rendimiento. Análisis profundo y estimaciones que permiten medir su rendimiento. Detección de cualquier problema existente y ajuste del flujo de trabajo para ganar en eficiencia. El método Kanban es muy flexible y le permite perfeccionar sus procesos para obtener los mejores resultados.

  \item Organización y colaboración. La metodología Kanban le permite beneficiarse del poder del enfoque visual, mediante el uso de columnas, carriles y tarjetas de colores. Usted será capaz de trabajar en el mismo tablero que su equipo y colaborar en tiempo real. Los tableros digitales Kanban le permitirán acceder a su flujo de trabajo desde cualquier sitio, compartir tareas con facilidad y comunicarse en su trabajo con sus colegas.

  \item Distribución del trabajo. Una cómoda visión general de los trabajos en curso y menos tiempo dedicado a la distribución y presentación de los trabajos. Las estimaciones son imperfectas, por consiguiente, un flujo constante de tareas reducirá su tiempo de espera y el tiempo dedicado a la asignación de tareas. Usted selecciona sus tareas, por tanto no tendrá que esperar a que la tarea vaya hacia usted.
\end{enumerate}

El método Kanban se basa en la idea de visualizar lo que se está haciendo ahora, lo que se está terminando y lo que hay que hacer a continuación.

\subsection{Seguimiento}

\subsubsection{Estado de las tareas}

Para realizar el seguimiento del proceso utilizamos un Kanban board a través de Waffle.io\cite{waffle}. Esta aplicación permite visualizar los issues cargados en GitHub como tarjetas en un tablero de kanban. Definimos las siguientes columnas para el tablero:

\begin{enumerate}
    \item \textbf{Backlog} Listado priorizado de todos los requisitos que se elicitaron para implementar. Nuevos requisitos se ingresan en esta lista. Las tarjetas en esta lista no están asignadas a ningún integrante.
    \item \textbf{Ready} Listado de tareas que ya tienen un análisis detallado y están listas para ser implementadas. Constituye un segundo backlog de cosas que están listas para implementar.
    \item \textbf{In Progress} Tareas en desarrollo activo. Todas las tarjetas en esta columna están asignadas a un desarrollador. No puede haber más de una tarjeta en esta columna para cada desarrollador.
    \item \textbf{Review} Tareas que están pendientes para realizar el proceso de revisión cruzada. Se asignan al miembro del equipo que realizó la implementación, pero se adjunta la revisión asignada al integrante que va a revisar la misma.
    \item \textbf{Done} Una vez que se completa la revisión y se integran los cambios al master, el sistema automáticamente corre los tests y realiza el deploy al entorno productivo. Cuando este proceso automático termina, la tarjeta asociada se mueve a esta columna.
\end{enumerate}


\subsection{Continuous delivery}

Los procesos de testing y puesta en producción están altamente integrados y fueron basados en el proceso de Continuous Delivery\cite{cd}.

Debido a que se utilizó una metodología de desarrollo basada en BDD\cite{bdd}, cada cambio que se desarrolló fue acompañado con una especificación ejecutable de comportamiento. En total, se desarrollaron cerca de 800 especificaciones individuales utilizando Karma.js\cite{karma} y Jasmine\cite{jasmine}. El conjunto total de especificaciones se ejecuta automáticamente cada vez que se publicaba código en GitHub a través de TravisCI\cite{travis}, y sólo se puede integrar el código en el master cuando estas ejecuciones son exitosas.

Cuando el código es integrado en el master, TravisCI ejecuta nuevamente las especificaciones. Si esta nueva ejecución es exitosa, el código es automáticamente empaquetado y subido al servidor de Surge.sh, sin intervención manual de ningún miembro del equipo.

%-----------------------------------------------------------------------
% Futuro
%-----------------------------------------------------------------------
\section{Trabajos posteriores}

\subsection{Propuestas}

Se describen a continuación algunos posibles trabajos posteriores que pueden basarse en el presente trabajo para expandirlo:

\subsubsection{Lenguaje Oz}

Como se detallo en la sección de alcance, sólo se incluyeron ciertas construcciones propias del lenguaje. En un trabajo posterior podría terminar de implementarse el resto de los modelos de programación, incluyendo de esta forma construcciones propias de Object Oriented Programming, Shared-State Concurrency, Relational Programming y Distributed Programming. Este trabajo también podría incluir las construcciones de los paradigmas ya implementados que quedaron afuera, como las expresiones lógicas de conjunción y disyunción.

\subsubsection{Compilación a otras plataformas}

Debido a que el parser y compilador es independiente del modelo de ejecución, es posible extender el proyecto para que incluya otras plataformas objetivo, como WebAssembly\cite{wasm}. Esto permitiría ejecutar código Oz en otros entornos: en el caso de compilar a WebAssembly esto permitiría ejecutar código Oz en browsers.


\subsection{Licencia}

Se decidió licenciar el trabajo utilizando la licencia MIT\cite{mit}, por su permisibilidad para la creación de trabajos derivados.

\begin{displayquote}

Copyright 2018 Kozily

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

\end{displayquote}

%-----------------------------------------------------------------------
% Conclusiones
%-----------------------------------------------------------------------
\section{Conclusiones}

[TODO]: Completar esta sección

%-----------------------------------------------------------------------
% Bibliografia
%-----------------------------------------------------------------------
\begin{thebibliography}{9}

\bibitem{ctmcp} 
Peter Van Roy, Seif Haridi,
\textit{Concepts, Techniques, and Models of Computer Programming},
MIT Press, 2003.

\bibitem{replit}
Repl.it,
\textit{Repl.it},
\url{https://repl.it/}

\bibitem{codeanywhere}
CodeAnywhere,
\textit{CodeAnywhere},
\url{https://codeanywhere.com/}

\bibitem{parsing}
Wikipedia,
\textit{Parsing},
\url{https://en.wikipedia.org/wiki/Parsing}

\bibitem{ast}
Wikipedia,
\textit{Abstract Syntax Tree},
\url{https://en.wikipedia.org/wiki/Abstract_syntax_tree}

\bibitem{immutable}
Facebook,
\textit{Immutable.js},
\url{http://facebook.github.io/immutable-js/}


\bibitem{nearley}
Nearley,
\textit{Nearley},
\url{https://nearley.js.org/}


\bibitem{earley}
Wikipedia,
\textit{Earley parser},
\url{https://en.wikipedia.org/wiki/Earley_parser}

\bibitem{earley}
Wikipedia,
\textit{Earley parser},
\url{https://en.wikipedia.org/wiki/Earley_parser}

\bibitem{persistentdatastructures}
Thai Pangsakulyanont,
\textit{Immutable.js, persistent data structures and structural sharing},
\url{https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2}

\bibitem{fold}
Wikipedia,
\textit{Fold (higher-order function)},
\url{https://en.wikipedia.org/wiki/Fold_(higher-order_function)}

\bibitem{react}
Facebook,
\textit{React.js},
\url{https://reactjs.org/}

\bibitem{redux}
Redux,
\textit{Redux.js},
\url{https://redux.js.org/}

\bibitem{webpack}
Webpack,
\textit{Webpack},
\url{https://webpack.js.org/}

\bibitem{surge}
Surge,
\textit{Surge.sh},
\url{https://surge.sh/}

\bibitem{slack}
Slack,
\textit{Slack.com},
\url{https://slack.com/}

\bibitem{github}
GitHub,
\textit{GitHub.com},
\url{https://github.com/}

\bibitem{githubmilestones}
GitHub,
\textit{About milestones},
\url{https://help.github.com/articles/about-milestones/}

\bibitem{toggl}
Toggl,
\textit{Toggl.com},
\url{https://toggl.com/}

\bibitem{scrum}
The Home of Scrum,
\textit{Qué es scrum},
\url{https://www.scrum.org/resources/blog/que-es-scrum}

\bibitem{kanban}
Wikipedia,
\textit{Kanban development process},
\url{https://en.wikipedia.org/wiki/Kanban_(development)}

\bibitem{waffle}
Waffle,
\textit{Waffle.io},
\url{https://waffle.io/kozily/admin}

\bibitem{cd}
Continuous Delivery,
\textit{What is Continuous Delivery},
\url{https://continuousdelivery.com/}

\bibitem{bdd}
Agile Alliance,
\textit{Behaviour Driven Development},
\url{https://www.agilealliance.org/glossary/bdd/}

\bibitem{karma}
Karma,
\textit{Karma},
\url{https://karma-runner.github.io/2.0/index.html}

\bibitem{jasmine}
Jasmine,
\textit{Jasmine},
\url{https://jasmine.github.io/}

\bibitem{travis}
TravisCI,
\textit{TravisCI.org},
\url{https://travis-ci.org/}

\bibitem{wasm}
Web Assembly,
\textit{Web Assembly},
\url{http://webassembly.org/}

\end{thebibliography}

\end{document}
